// Service to generate secure contract ready tokens
// Creates UUID v4 tokens for unguessable, non-sequential contract ready URLs

import { supabase } from '../index.js';

export interface CreateTokenOptions {
  dealId: string;
  creatorId: string;
  expiresAt?: Date | null; // null = no expiry (default)
}

export interface ContractReadyToken {
  id: string;
  deal_id: string;
  created_at: string;
  created_by: string;
  expires_at: string | null;
  is_active: boolean;
  revoked_at: string | null;
}

/**
 * Create a secure contract ready token for a deal
 * @param options Token creation options
 * @returns The created token
 */
export async function createContractReadyToken(
  options: CreateTokenOptions
): Promise<ContractReadyToken> {
  const { dealId, creatorId, expiresAt } = options;

  // Validate inputs
  if (!dealId || !creatorId) {
    throw new Error('dealId and creatorId are required');
  }

  // Verify deal exists and belongs to creator
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('id, creator_id')
    .eq('id', dealId)
    .eq('creator_id', creatorId)
    .maybeSingle();

  if (dealError || !deal) {
    throw new Error('Deal not found or access denied');
  }

  // Create token (UUID v4 is generated by database default)
  // Note: We'll need to create this table in a migration
  // For now, we'll use a similar pattern to brand_reply_tokens
  const { data: token, error: tokenError } = await supabase
    .from('contract_ready_tokens')
    .insert({
      deal_id: dealId,
      created_by: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    } as any)
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[ContractReadyTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create contract ready token');
  }

  return token;
}

/**
 * Get contract ready token info (public access for contract ready page)
 * @param tokenId Token ID
 * @returns Token info with deal details
 */
export async function getContractReadyTokenInfo(tokenId: string): Promise<{
  token: ContractReadyToken;
  deal: any;
  creatorName: string;
} | null> {
  // Validate token format (UUID v4)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(tokenId.trim())) {
    return null;
  }

  // Fetch token
  const { data: tokenData, error: tokenError } = await supabase
    .from('contract_ready_tokens')
    .select('*')
    .eq('id', tokenId.trim())
    .eq('is_active', true)
    .is('revoked_at', null)
    .maybeSingle();

  if (tokenError || !tokenData) {
    return null;
  }

  const token = tokenData as any;

  // Fetch deal
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('*')
    .eq('id', token.deal_id)
    .maybeSingle();

  if (dealError || !deal) {
    return null;
  }

  // Fetch creator profile
  const { data: creator, error: creatorError } = await supabase
    .from('profiles')
    .select('first_name, last_name, email')
    .eq('id', deal.creator_id)
    .maybeSingle();

  if (creatorError || !creator) {
    return null;
  }

  const creatorName = creator.first_name && creator.last_name
    ? `${creator.first_name} ${creator.last_name}`
    : creator.first_name || creator.email?.split('@')[0] || 'Creator';

  return {
    token: {
      id: token.id,
      deal_id: token.deal_id,
      created_at: token.created_at,
      created_by: token.created_by,
      expires_at: token.expires_at,
      is_active: token.is_active,
      revoked_at: token.revoked_at,
    },
    deal,
    creatorName,
  };
}

