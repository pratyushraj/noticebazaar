// Service to generate secure contract ready tokens
// Creates UUID v4 tokens for unguessable, non-sequential contract ready URLs

import { supabase } from '../index.js';

export interface CreateTokenOptions {
  dealId?: string | null; // Optional - can use submissionId instead
  submissionId?: string | null; // Optional - can use dealId instead
  creatorId: string;
  expiresAt?: Date | null; // null = no expiry (default)
}

export interface ContractReadyToken {
  id: string;
  deal_id: string | null; // Nullable - can be null if submission_id is set
  submission_id: string | null; // Nullable - can be null if deal_id is set
  created_at: string;
  created_by: string;
  expires_at: string | null;
  is_active: boolean;
  revoked_at: string | null;
}

/**
 * Create a secure contract ready token for a deal
 * @param options Token creation options
 * @returns The created token
 */
export async function createContractReadyToken(
  options: CreateTokenOptions
): Promise<ContractReadyToken> {
  const { dealId, submissionId, creatorId, expiresAt } = options;

  // Validate inputs - must have either dealId or submissionId
  if (!creatorId) {
    throw new Error('creatorId is required');
  }

  if (!dealId && !submissionId) {
    throw new Error('Either dealId or submissionId is required');
  }

  // Verify deal exists and belongs to creator (if dealId provided)
  if (dealId) {
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('id, creator_id')
    .eq('id', dealId)
    .eq('creator_id', creatorId)
    .maybeSingle();

  if (dealError || !deal) {
    throw new Error('Deal not found or access denied');
    }
  }

  // Verify submission exists and belongs to creator (if submissionId provided)
  if (submissionId) {
    const { data: submission, error: submissionError } = await supabase
      .from('deal_details_submissions')
      .select('id, creator_id')
      .eq('id', submissionId)
      .eq('creator_id', creatorId)
      .maybeSingle();

    if (submissionError || !submission) {
      throw new Error('Submission not found or access denied');
    }
  }

  // Create token (UUID v4 is generated by database default)
  const { data: token, error: tokenError } = await (supabase as any)
    .from('contract_ready_tokens')
    .insert({
      deal_id: dealId || null,
      submission_id: submissionId || null,
      created_by: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    })
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[ContractReadyTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create contract ready token');
  }

  return token as any as ContractReadyToken;
}

/**
 * Get contract ready token info (public access for contract ready page)
 * @param tokenId Token ID
 * @returns Token info with deal details
 */
export async function getContractReadyTokenInfo(tokenId: string): Promise<{
  token: ContractReadyToken;
  deal: any;
  creatorName: string;
  creatorEmail: string | null;
  creatorAddress: string | null;
} | null> {
  // Validate token format (UUID v4)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(tokenId.trim())) {
    return null;
  }

  // Fetch token
  console.log('[ContractReadyTokenService] Looking up token:', tokenId.trim());
  const { data: tokenData, error: tokenError } = await (supabase as any)
    .from('contract_ready_tokens')
    .select('*')
    .eq('id', tokenId.trim())
    .maybeSingle();

  if (tokenError) {
    console.error('[ContractReadyTokenService] Error fetching token:', tokenError);
    return null;
  }

  if (!tokenData) {
    console.warn('[ContractReadyTokenService] Token not found in database:', tokenId.trim());
    return null;
  }

  console.log('[ContractReadyTokenService] Token found:', {
    id: tokenData.id,
    deal_id: tokenData.deal_id,
    is_active: tokenData.is_active,
    revoked_at: tokenData.revoked_at,
    expires_at: tokenData.expires_at
  });

  // Check if token is active and not revoked
  const isTokenInvalid = !tokenData.is_active || 
                         tokenData.revoked_at || 
                         (tokenData.expires_at && new Date(tokenData.expires_at) < new Date());
  
  if (isTokenInvalid) {
    console.warn('[ContractReadyTokenService] Token is invalid:', {
      id: tokenData.id,
      is_active: tokenData.is_active,
      revoked_at: tokenData.revoked_at,
      expires_at: tokenData.expires_at,
      deal_id: tokenData.deal_id
    });
    
    // If token is invalid but we have a deal_id, try to find a newer active token for the same deal
    if (tokenData.deal_id) {
      console.log('[ContractReadyTokenService] Looking for newer active token for deal:', tokenData.deal_id);
      const { data: newerToken, error: newerTokenError } = await (supabase as any)
        .from('contract_ready_tokens')
        .select('id')
        .eq('deal_id', tokenData.deal_id)
        .eq('is_active', true)
        .is('revoked_at', null)
        .order('created_at', { ascending: false })
        .limit(1)
        .maybeSingle();
      
      if (!newerTokenError && newerToken && newerToken.id) {
        console.log('[ContractReadyTokenService] Found newer active token:', newerToken.id);
        // Return null but we'll check for newer token in the API route
        // For now, return null and let the API route handle the redirect logic
    return null;
  }
  }

    return null;
  }

  const token = tokenData as any;

  // Fetch deal or submission - prioritize submission_id if present
  let deal: any = null;
  let creatorId: string | null = null;

  // If token has submission_id, fetch submission first (deals are created when signed)
  if (token.submission_id) {
    console.log('[ContractReadyTokenService] Token has submission_id, fetching submission:', token.submission_id);
    const { data: submission, error: submissionError } = await supabase
      .from('deal_details_submissions')
      .select('*, deal_details_tokens!inner(*)')
      .eq('id', token.submission_id)
      .maybeSingle();

      if (!submissionError && submission && submission.form_data) {
        console.log('[ContractReadyTokenService] Found submission with submission_id');
        const formData = submission.form_data as any;
        creatorId = submission.creator_id;
        
        // Fetch creator profile to get name, email, and address
        const { data: creatorProfile, error: creatorProfileError } = await supabase
          .from('profiles')
          .select('first_name, last_name, location, address, business_name')
          .eq('id', submission.creator_id)
          .maybeSingle();

        if (creatorProfileError) {
          console.warn('[ContractReadyTokenService] Error fetching creator profile from submission:', creatorProfileError);
        } else if (!creatorProfile) {
          console.warn('[ContractReadyTokenService] Creator profile not found for creator_id:', submission.creator_id);
        } else {
          console.log('[ContractReadyTokenService] Found creator profile:', {
            creatorId: submission.creator_id,
            firstName: creatorProfile.first_name,
            lastName: creatorProfile.last_name,
            businessName: creatorProfile.business_name,
            hasFirstName: !!creatorProfile.first_name,
            hasLastName: !!creatorProfile.last_name,
            hasBusinessName: !!creatorProfile.business_name,
            hasLocation: !!creatorProfile.location,
            hasAddress: !!creatorProfile.address,
            fullProfile: creatorProfile
          });
        }

        // Get email from auth.users
        let creatorEmailFromAuth: string | null = null;
        try {
          const { data: authUser } = await supabase.auth.admin.getUserById(submission.creator_id);
          creatorEmailFromAuth = authUser?.user?.email || null;
          if (creatorEmailFromAuth) {
            console.log('[ContractReadyTokenService] Found creator email from auth:', creatorEmailFromAuth);
          }
        } catch (authError) {
          console.warn('[ContractReadyTokenService] Could not fetch creator email from auth:', authError);
        }

        // Create a deal-like object from submission data
        deal = {
          id: submission.deal_id || null, // May have deal_id if deal was created
          creator_id: submission.creator_id,
          brand_name: formData.brandName || 'Brand',
          deal_amount: formData.dealType === 'paid' && formData.paymentAmount
            ? parseFloat(formData.paymentAmount) || 0
            : 0,
          deliverables: JSON.stringify(formData.deliverables || []),
          due_date: formData.deadline || new Date().toISOString().split('T')[0],
          payment_expected_date: formData.deadline || new Date().toISOString().split('T')[0],
          status: 'CONTRACT_READY', // Contract is ready for signing
          platform: 'Other',
          deal_type: formData.dealType || 'paid',
          created_via: 'deal_details_form',
          brand_address: formData.companyAddress || null,
          brand_email: formData.companyEmail || null,
          contract_file_url: null, // Will be set when contract is generated
          contract_status: 'DraftGenerated',
          contract_version: 'v3',
          // Store creator info in deal object for easier access
          _creator_profile: creatorProfile,
          _creator_email: creatorEmailFromAuth,
        };
      }
  }

  // If no deal from submission, try to fetch deal by deal_id
  if (!deal && token.deal_id) {
    const { data: dealData, error: dealError } = await supabase
    .from('brand_deals')
    .select('*')
    .eq('id', token.deal_id)
    .maybeSingle();

    if (!dealError && dealData) {
      deal = dealData;
      creatorId = deal.creator_id;
    }
  }

  // If deal still doesn't exist and no submission_id, try to find submission by matching
  if (!deal && !token.submission_id) {
    console.log('[ContractReadyTokenService] Deal not found and no submission_id, looking for submission data...', {
      tokenId: tokenId.trim(),
      dealId: token.deal_id,
      createdBy: token.created_by,
      createdAt: token.created_at
    });

    // Try to find submission by matching creator and finding most recent submission without deal_id
    // Match by creator_id from token and find submissions created around the same time as token
    if (token.created_by) {
      // Try to find submission by matching creator and finding most recent submission without deal_id
      // Match by creator_id from token and find submissions created around the same time as token
      if (token.created_by) {
        console.log('[ContractReadyTokenService] Looking for submission for creator:', token.created_by, 'created_at:', token.created_at);
        
        // Find the most recent submission for this creator that doesn't have a deal_id
        // and was created around the same time as the token (within 1 hour)
        const tokenCreatedAt = new Date(token.created_at);
        const oneHourBefore = new Date(tokenCreatedAt.getTime() - 60 * 60 * 1000);
        const oneHourAfter = new Date(tokenCreatedAt.getTime() + 60 * 60 * 1000);

        console.log('[ContractReadyTokenService] Searching submissions between:', oneHourBefore.toISOString(), 'and', oneHourAfter.toISOString());

        const { data: submissions, error: submissionsError } = await supabase
          .from('deal_details_submissions')
          .select('*, deal_details_tokens!inner(*)')
          .eq('creator_id', token.created_by)
          .is('deal_id', null)
          .gte('created_at', oneHourBefore.toISOString())
          .lte('created_at', oneHourAfter.toISOString())
          .order('created_at', { ascending: false })
          .limit(5);

        if (submissionsError) {
          console.error('[ContractReadyTokenService] Error fetching submissions:', submissionsError);
        } else {
          console.log('[ContractReadyTokenService] Found', submissions?.length || 0, 'submissions in time window');
        }

        // If no submissions found in time window, try just the most recent one for this creator
        let matchingSubmission = submissions && submissions.length > 0 ? submissions[0] : null;
        
        if (!matchingSubmission) {
          console.log('[ContractReadyTokenService] No submissions in time window, trying most recent submission');
          const { data: recentSubmission, error: recentError } = await supabase
            .from('deal_details_submissions')
            .select('*, deal_details_tokens!inner(*)')
            .eq('creator_id', token.created_by)
            .is('deal_id', null)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();
          
          if (recentError) {
            console.error('[ContractReadyTokenService] Error fetching recent submission:', recentError);
          } else {
            console.log('[ContractReadyTokenService] Found recent submission:', recentSubmission ? 'yes' : 'no');
          }
          
          matchingSubmission = recentSubmission;
        }

        if (matchingSubmission && matchingSubmission.form_data) {
          const formData = matchingSubmission.form_data as any;
          creatorId = matchingSubmission.creator_id;
          
          // Create a deal-like object from submission data
          deal = {
            id: null,
            creator_id: matchingSubmission.creator_id,
            brand_name: formData.brandName || 'Brand',
            deal_amount: formData.dealType === 'paid' && formData.paymentAmount
              ? parseFloat(formData.paymentAmount) || 0
              : 0,
            deliverables: JSON.stringify(formData.deliverables || []),
            due_date: formData.deadline || new Date().toISOString().split('T')[0],
            payment_expected_date: formData.deadline || new Date().toISOString().split('T')[0],
            status: 'CONTRACT_READY',
            platform: 'Other',
            deal_type: formData.dealType || 'paid',
            created_via: 'deal_details_form',
            brand_address: formData.companyAddress || null,
            brand_email: formData.companyEmail || null,
            contract_file_url: null,
            contract_status: 'DraftGenerated',
            contract_version: 'v3',
          };
          
          console.log('[ContractReadyTokenService] Found submission data for token, created deal-like object');
        }
      }
    }
  }

  if (!deal || !creatorId) {
    console.warn('[ContractReadyTokenService] Could not find deal or submission data for token:', tokenId.trim());
    return null;
  }

  creatorId = creatorId || deal.creator_id;

  // Check if we already fetched creator profile data from submission
  let creator: any = null;
  let creatorEmail: string | null = null;
  
  if (deal._creator_profile) {
    // Use already-fetched creator profile from submission
    creator = deal._creator_profile;
    creatorEmail = deal._creator_email || null;
    // Clean up temporary fields
    delete deal._creator_profile;
    delete deal._creator_email;
  } else {
    // Fetch creator profile with address
    const { data: creatorData, error: creatorError } = await supabase
      .from('profiles')
      .select('first_name, last_name, location, address, business_name')
      .eq('id', creatorId)
      .maybeSingle();

    if (creatorError) {
      console.error('[ContractReadyTokenService] Error fetching creator profile:', creatorError);
      // Don't return null - continue with default values
      creator = null;
    } else {
      creator = creatorData;
    }

    // Get email from auth.users
    try {
      const { data: authUser } = await supabase.auth.admin.getUserById(creatorId);
      creatorEmail = authUser?.user?.email || null;
    } catch (authError) {
      console.warn('[ContractReadyTokenService] Could not fetch creator email from auth:', authError);
    }
  }

  // Construct creator name with better fallbacks
  // Don't use email username - only use actual profile data
  let creatorName: string | null = null;
  if (creator) {
    // Try business_name first (for business accounts)
    if (creator.business_name && creator.business_name.trim()) {
      creatorName = creator.business_name.trim();
    } else if (creator.first_name && creator.last_name) {
      creatorName = `${creator.first_name} ${creator.last_name}`.trim();
    } else if (creator.first_name) {
      creatorName = creator.first_name.trim();
    } else if (creator.last_name) {
      creatorName = creator.last_name.trim();
    }
  }
  
  // If no name found, use default
  if (!creatorName || creatorName === '') {
    creatorName = 'Creator';
  }
  
  console.log('[ContractReadyTokenService] Constructed creator name:', {
    finalName: creatorName,
    hadFirstName: !!creator?.first_name,
    hadLastName: !!creator?.last_name,
    hadBusinessName: !!creator?.business_name,
    firstName: creator?.first_name,
    lastName: creator?.last_name,
    businessName: creator?.business_name
  });

  // Get creator address (prefer location field, fallback to address field)
  let creatorAddress = creator ? (creator.location || creator.address || null) : null;
  
  // Clean up address - remove empty strings and trim whitespace
  if (creatorAddress && typeof creatorAddress === 'string') {
    creatorAddress = creatorAddress.trim();
    if (creatorAddress === '') {
      creatorAddress = null;
    }
  }

  // Log final creator data being returned
  console.log('[ContractReadyTokenService] Returning creator data:', {
    creatorId,
    creatorName,
    creatorEmail,
    creatorAddress,
    hasCreatorProfile: !!creator,
    creatorProfileData: creator ? {
      first_name: creator.first_name,
      last_name: creator.last_name,
      location: creator.location,
      address: creator.address,
      locationType: typeof creator.location,
      addressType: typeof creator.address,
      locationValue: creator.location,
      addressValue: creator.address
    } : null
  });

  return {
    token: {
      id: token.id,
      deal_id: token.deal_id,
      created_at: token.created_at,
      created_by: token.created_by,
      expires_at: token.expires_at,
      is_active: token.is_active,
      revoked_at: token.revoked_at,
    },
    deal,
    creatorName,
    creatorEmail,
    creatorAddress,
  };
}

