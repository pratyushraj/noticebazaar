// Service to generate secure contract ready tokens
// Creates UUID v4 tokens for unguessable, non-sequential contract ready URLs

import { supabase } from '../index.js';

export interface CreateTokenOptions {
  dealId: string;
  creatorId: string;
  expiresAt?: Date | null; // null = no expiry (default)
}

export interface ContractReadyToken {
  id: string;
  deal_id: string;
  created_at: string;
  created_by: string;
  expires_at: string | null;
  is_active: boolean;
  revoked_at: string | null;
}

/**
 * Create a secure contract ready token for a deal
 * @param options Token creation options
 * @returns The created token
 */
export async function createContractReadyToken(
  options: CreateTokenOptions
): Promise<ContractReadyToken> {
  const { dealId, creatorId, expiresAt } = options;

  // Validate inputs
  if (!dealId || !creatorId) {
    throw new Error('dealId and creatorId are required');
  }

  // Verify deal exists and belongs to creator
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('id, creator_id')
    .eq('id', dealId)
    .eq('creator_id', creatorId)
    .maybeSingle();

  if (dealError || !deal) {
    throw new Error('Deal not found or access denied');
  }

  // Create token (UUID v4 is generated by database default)
  // Note: We'll need to create this table in a migration
  // For now, we'll use a similar pattern to brand_reply_tokens
  const { data: token, error: tokenError } = await (supabase as any)
    .from('contract_ready_tokens')
    .insert({
      deal_id: dealId,
      created_by: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    })
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[ContractReadyTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create contract ready token');
  }

  return token as any as ContractReadyToken;
}

/**
 * Get contract ready token info (public access for contract ready page)
 * @param tokenId Token ID
 * @returns Token info with deal details
 */
export async function getContractReadyTokenInfo(tokenId: string): Promise<{
  token: ContractReadyToken;
  deal: any;
  creatorName: string;
} | null> {
  // Validate token format (UUID v4)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(tokenId.trim())) {
    return null;
  }

  // Fetch token
  console.log('[ContractReadyTokenService] Looking up token:', tokenId.trim());
  const { data: tokenData, error: tokenError } = await (supabase as any)
    .from('contract_ready_tokens')
    .select('*')
    .eq('id', tokenId.trim())
    .maybeSingle();

  if (tokenError) {
    console.error('[ContractReadyTokenService] Error fetching token:', tokenError);
    return null;
  }

  if (!tokenData) {
    console.warn('[ContractReadyTokenService] Token not found in database:', tokenId.trim());
    return null;
  }

  console.log('[ContractReadyTokenService] Token found:', {
    id: tokenData.id,
    deal_id: tokenData.deal_id,
    is_active: tokenData.is_active,
    revoked_at: tokenData.revoked_at,
    expires_at: tokenData.expires_at
  });

  // Check if token is active and not revoked
  if (!tokenData.is_active) {
    console.warn('[ContractReadyTokenService] Token is not active:', tokenData.id);
    return null;
  }

  if (tokenData.revoked_at) {
    console.warn('[ContractReadyTokenService] Token has been revoked:', tokenData.id, 'revoked_at:', tokenData.revoked_at);
    return null;
  }

  if (tokenData.expires_at && new Date(tokenData.expires_at) < new Date()) {
    console.warn('[ContractReadyTokenService] Token has expired:', tokenData.id, 'expires_at:', tokenData.expires_at);
    return null;
  }

  const token = tokenData as any;

  // Fetch deal
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('*')
    .eq('id', token.deal_id)
    .maybeSingle();

  if (dealError || !deal) {
    return null;
  }

  // Fetch creator profile
  const { data: creator, error: creatorError } = await supabase
    .from('profiles')
    .select('first_name, last_name')
    .eq('id', deal.creator_id)
    .maybeSingle();

  if (creatorError || !creator) {
    console.error('[ContractReadyTokenService] Error fetching creator profile:', creatorError);
    return null;
  }

  // Get email from auth.users
  let creatorEmail: string | null = null;
  try {
    const { data: authUser } = await supabase.auth.admin.getUserById(deal.creator_id);
    creatorEmail = authUser?.user?.email || null;
  } catch (authError) {
    console.warn('[ContractReadyTokenService] Could not fetch creator email from auth:', authError);
  }

  const creatorName = creator.first_name && creator.last_name
    ? `${creator.first_name} ${creator.last_name}`
    : creator.first_name || creatorEmail?.split('@')[0] || 'Creator';

  return {
    token: {
      id: token.id,
      deal_id: token.deal_id,
      created_at: token.created_at,
      created_by: token.created_by,
      expires_at: token.expires_at,
      is_active: token.is_active,
      revoked_at: token.revoked_at,
    },
    deal,
    creatorName,
  };
}

