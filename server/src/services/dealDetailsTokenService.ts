import { supabase } from '../index.js';
import { sendBrandFormSubmissionEmail } from './brandFormSubmissionEmailService.js';

/**
 * Determines if brand confirmation/clarification page is required
 * Returns true if any problematic conditions are detected
 */
export function shouldRequireBrandConfirmation(deal: any): boolean {
  // If creator requested edits earlier
  if (deal.creatorRequestedChanges) return true;

  // If AI flagged missing clarity
  if (deal.flags?.requiresClarification === true) return true;

  // If usage rights missing or incomplete
  if (!deal.usage || !deal.usage.duration) return true;

  // If payment terms vague or missing
  if (!deal.payment?.timeline || !deal.payment?.method) return true;

  // If exclusivity unclear
  if (deal.exclusivity?.status === "unknown") return true;

  // If brand skipped critical fields
  const required = ["deliverables", "deadline", "amount"];
  for (const field of required) {
    if (!deal[field]) return true;
  }

  // If nothing problematic → NO confirmation needed
  return false;
}

export interface DealDetailsToken {
  id: string;
  creator_id: string;
  is_active: boolean;
  expires_at: string | null;
  revoked_at: string | null;
  used_at: string | null; // Timestamp when brand submitted (locks form)
  created_at: string;
  updated_at: string;
}

export interface CreateDealDetailsTokenOptions {
  creatorId: string;
  expiresAt?: Date | null;
}

/**
 * Create a secure deal details token
 * @param options Token creation options
 * @returns The created token
 */
export async function createDealDetailsToken(
  options: CreateDealDetailsTokenOptions
): Promise<DealDetailsToken> {
  const { creatorId, expiresAt } = options;

  // Validate inputs
  if (!creatorId) {
    throw new Error('creatorId is required');
  }

  // Create token (UUID v4 is generated by database default)
  const { data: token, error: tokenError } = await supabase
    .from('deal_details_tokens')
    .insert({
      creator_id: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    })
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[DealDetailsTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create deal details token');
  }

  return token;
}

/**
 * Get token info (public access for form page)
 * @param tokenId Token ID
 * @returns Token info with creator name
 */
export async function getDealDetailsTokenInfo(tokenId: string): Promise<{
  token: DealDetailsToken;
  creatorName: string;
} | null> {
  // Validate token format (UUID v4)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(tokenId.trim())) {
    return null;
  }

  // Fetch token with creator info
  const { data: tokenData, error: tokenError } = await supabase
    .from('deal_details_tokens')
    .select(`
      *,
      profiles:creator_id (
        first_name,
        last_name
      )
    `)
    .eq('id', tokenId.trim())
    .maybeSingle();

  if (tokenError || !tokenData) {
    return null;
  }

  // Check if token is active
  if (!tokenData.is_active || tokenData.revoked_at) {
    return null;
  }

  // Check if token is expired
  if (tokenData.expires_at) {
    const expiresAt = new Date(tokenData.expires_at);
    if (expiresAt < new Date()) {
      return null;
    }
  }

  // Note: We still return token info even if used_at is set (for read-only view)

  // Extract creator name
  const profile = tokenData.profiles as any;
  const creatorName = profile
    ? `${profile.first_name || ''} ${profile.last_name || ''}`.trim() || 'the creator'
    : 'the creator';

  return {
    token: tokenData as DealDetailsToken,
    creatorName,
  };
}

/**
 * Submit deal details form
 * @param tokenId Token ID
 * @param formData Form submission data
 * @returns Created deal ID (if deal was created)
 */
export async function submitDealDetails(
  tokenId: string,
  formData: any
): Promise<{ submissionId: string; dealId: string | null; contractReadyToken: string | null }> {
  // Validate token
  const tokenInfo = await getDealDetailsTokenInfo(tokenId);
  if (!tokenInfo) {
    throw new Error('Invalid or expired token');
  }

  const { token } = tokenInfo;

  // Check if token has already been used (immutability)
  if (token.used_at) {
    throw new Error('This form has already been submitted and cannot be edited. Please contact the creator for changes.');
  }

  // Mark token as used (lock the form)
  const { error: updateError } = await supabase
    .from('deal_details_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('id', tokenId);

  if (updateError) {
    console.error('[DealDetailsTokenService] Token update error:', updateError);
    // Continue anyway - submission is more important
  }

  // Create submission
  const { data: submission, error: submissionError } = await supabase
    .from('deal_details_submissions')
    .insert({
      token_id: tokenId,
      creator_id: token.creator_id,
      form_data: formData,
    })
    .select()
    .single();

  if (submissionError || !submission) {
    console.error('[DealDetailsTokenService] Submission error:', submissionError);
    throw new Error('Failed to submit deal details');
  }

  // Create draft deal from form data
  let dealId: string | null = null;
  try {
    const dealData: any = {
      creator_id: token.creator_id,
      brand_name: formData.brandName || 'Brand',
      deal_amount: formData.dealType === 'paid' && formData.paymentAmount
        ? parseFloat(formData.paymentAmount) || 0
        : 0,
      deliverables: JSON.stringify(formData.deliverables || []),
      due_date: formData.deadline || new Date().toISOString().split('T')[0],
      payment_expected_date: formData.deadline || new Date().toISOString().split('T')[0],
      status: 'Brand_Details_Submitted', // Special status for creator review
      platform: 'Other',
      deal_type: formData.dealType || 'paid',
      created_via: 'deal_details_form',
      // Save brand address from company address (fetched via GST lookup)
      brand_address: formData.companyAddress || null,
      brand_email: formData.companyEmail || null,
    };

    const { data: deal, error: dealError } = await supabase
      .from('brand_deals')
      .insert(dealData)
      .select()
      .single();

    if (!dealError && deal) {
      dealId = deal.id;

      // Update submission with deal_id
      await supabase
        .from('deal_details_submissions')
        .update({ deal_id: deal.id })
        .eq('id', submission.id);

      // Map formData to deal structure for confirmation check
      const dealForCheck = {
        creatorRequestedChanges: (deal as any).creator_requested_clarifications || false,
        flags: {
          requiresClarification: (deal as any).flags?.requiresClarification || false
        },
        usage: {
          duration: formData.usageRightsDuration || null
        },
        payment: {
          timeline: formData.paymentTimeline || null,
          method: formData.paymentMethod && formData.paymentMethod.length > 0 
            ? formData.paymentMethod[0] 
            : null
        },
        exclusivity: {
          status: formData.exclusivityPeriod === 'none' || !formData.exclusivityPeriod 
            ? 'none' 
            : formData.exclusivityPeriod ? 'specified' : 'unknown'
        },
        deliverables: formData.deliverables && formData.deliverables.length > 0 
          ? formData.deliverables 
          : null,
        deadline: formData.deadline || null,
        amount: formData.dealType === 'paid' && formData.paymentAmount
          ? parseFloat(formData.paymentAmount) || 0
          : 0
      };

      // ALWAYS generate contract immediately (removed confirmation check)
      try {
        console.log('[DealDetailsTokenService] Auto-generating contract immediately...');
        
        // Import contract generation service
        const { generateContractFromScratch } = await import('./contractGenerator.js');
        
        // Fetch creator details
        const { data: creator, error: creatorError } = await supabase
          .from('profiles')
          .select('id, first_name, last_name, address, location')
          .eq('id', token.creator_id)
          .single();
        
        // Get email from auth.users
        let creatorEmail: string | null = null;
        if (creator) {
          const { data: authUser } = await supabase.auth.admin.getUserById(token.creator_id);
          creatorEmail = authUser?.user?.email || null;
        }

        if (!creatorError && creator) {
          // Parse deliverables
          const deliverablesList = Array.isArray(formData.deliverables) 
            ? formData.deliverables.map((d: any) => 
                `${d.quantity || 1}x ${d.contentType || 'Content'} on ${d.platform || 'Platform'}`
              )
            : ['As per agreement'];

          // Build contract generation request
          const creatorName = creator.first_name && creator.last_name
            ? `${creator.first_name} ${creator.last_name}`
            : creator.first_name || creator.email?.split('@')[0] || 'Creator';

          // Get creator address - check both location and address fields, and validate it's not N/A
          let creatorAddress: string | null = null;
          const locationValue = creator.location;
          const addressValue = creator.address;
          
          // Prefer location field, fallback to address field
          const rawAddress = (locationValue && typeof locationValue === 'string' && locationValue.trim() !== '' && locationValue.toLowerCase() !== 'n/a')
            ? locationValue.trim()
            : (addressValue && typeof addressValue === 'string' && addressValue.trim() !== '' && addressValue.toLowerCase() !== 'n/a')
              ? addressValue.trim()
              : null;
          
          creatorAddress = rawAddress;

          const contractRequest = {
            brandName: formData.brandName || 'Brand',
            creatorName: creatorName,
            dealAmount: dealForCheck.amount,
            deliverables: deliverablesList,
            brandEmail: formData.companyEmail || null,
            brandAddress: formData.companyAddress || null,
            creatorEmail: creatorEmail || null,
            creatorAddress: creatorAddress,
            dealSchema: {
              usage_type: formData.usageRightsDuration || '3_months',
              usage_platforms: formData.deliverables?.map((d: any) => d.platform) || ['Instagram'],
              usage_duration: formData.usageRightsDuration || '3_months',
              paid_ads_allowed: formData.paidAdsAllowed || false,
              whitelisting_allowed: formData.whitelistingAllowed || false,
              exclusivity_enabled: formData.exclusivityPeriod && formData.exclusivityPeriod !== 'none',
              exclusivity_duration: formData.exclusivityPeriod || null,
              payment_method: formData.paymentMethod?.[0] || null,
              payment_timeline: formData.paymentTimeline || null,
            },
            usageType: formData.usageRightsDuration || '3_months',
            usagePlatforms: formData.deliverables?.map((d: any) => d.platform) || ['Instagram'],
            usageDuration: formData.usageRightsDuration || '3_months',
            paidAdsAllowed: formData.paidAdsAllowed || false,
            whitelistingAllowed: formData.whitelistingAllowed || false,
            exclusivityEnabled: formData.exclusivityPeriod && formData.exclusivityPeriod !== 'none',
            exclusivityCategory: null,
            exclusivityDuration: formData.exclusivityPeriod || null,
            terminationNoticeDays: null,
            jurisdictionCity: formData.companyState || null,
            additionalTerms: null,
          };

          // Generate contract
          const contractResult = await generateContractFromScratch(contractRequest);

          // Upload contract DOCX to storage
          const { data: uploadData, error: uploadError } = await supabase.storage
            .from('creator-assets')
            .upload(
              `contracts/${deal.id}/${contractResult.fileName}`,
              contractResult.contractDocx,
              {
                contentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                upsert: true
              }
            );

          if (!uploadError && uploadData) {
            // Get public URL
            const { data: urlData } = await supabase.storage
              .from('creator-assets')
              .getPublicUrl(uploadData.path);

            // Update deal with contract info and set CONTRACT_READY status
            await supabase
              .from('brand_deals')
              .update({
                contract_file_url: urlData.publicUrl,
                contract_status: 'DraftGenerated',
                contract_version: 'v3',
                contract_generated_at: new Date().toISOString(),
                status: 'CONTRACT_READY', // Contract is ready for brand to verify and sign
                updated_at: new Date().toISOString()
              })
              .eq('id', deal.id);

            console.log('[DealDetailsTokenService] Contract auto-generated successfully, status: CONTRACT_READY');

            // Log activity: Brand submitted collaboration details
            try {
              await supabase
                .from('analytics_events')
                .insert({
                  event_type: 'brand_submitted_details',
                  deal_id: deal.id,
                  creator_id: token.creator_id,
                  metadata: {
                    source: 'brand_form_submission',
                    brand_name: formData.brandName || 'Brand'
                  },
                  created_at: new Date().toISOString()
                });
            } catch (analyticsError) {
              console.error('[DealDetailsTokenService] Activity logging failed (non-fatal):', analyticsError);
            }

            // Log activity: Agreement auto-generated
            try {
              await supabase
                .from('analytics_events')
                .insert({
                  event_type: 'agreement_auto_generated',
                  deal_id: deal.id,
                  creator_id: token.creator_id,
                  metadata: {
                    source: 'brand_form_submission',
                    contract_version: 'v3'
                  },
                  created_at: new Date().toISOString()
                });
            } catch (analyticsError) {
              console.error('[DealDetailsTokenService] Activity logging failed (non-fatal):', analyticsError);
            }
          } else {
            console.error('[DealDetailsTokenService] Contract upload failed:', uploadError);
          }
        } else {
          console.error('[DealDetailsTokenService] Creator not found for contract generation');
        }
      } catch (contractError: any) {
        console.error('[DealDetailsTokenService] Contract auto-generation failed (non-fatal):', contractError);
        // Don't fail the submission if contract generation fails, but still set status
        if (dealId) {
          await supabase
            .from('brand_deals')
            .update({
              status: 'AGREEMENT_PREPARED',
              updated_at: new Date().toISOString()
            })
            .eq('id', dealId);
        }
      }
    } else if (dealError) {
      console.error('[DealDetailsTokenService] Deal creation error:', dealError);
      // If deal creation failed, try to update existing deal if deal_id exists in submission
      if (submission.deal_id) {
        console.log('[DealDetailsTokenService] Attempting to update existing deal with brand address');
        const { error: updateError } = await supabase
          .from('brand_deals')
          .update({
            brand_address: formData.companyAddress || null,
            brand_email: formData.companyEmail || null,
          })
          .eq('id', submission.deal_id);
        
        if (updateError) {
          console.error('[DealDetailsTokenService] Deal update error:', updateError);
        } else {
          console.log('[DealDetailsTokenService] Successfully updated existing deal with brand address');
          dealId = submission.deal_id;
        }
      }
    }
  } catch (error) {
    console.error('[DealDetailsTokenService] Deal creation error:', error);
    // Don't fail the submission if deal creation fails
  }

  // Send email notification to creator (non-blocking)
  if (dealId) {
    try {
      // Fetch creator's profile
      const { data: creatorProfile, error: profileError } = await supabase
        .from('profiles')
        .select('first_name, last_name')
        .eq('id', token.creator_id)
        .maybeSingle();

      // Get email from auth.users
      let creatorEmail: string | null = null;
      if (!profileError && creatorProfile) {
        const { data: authUser } = await supabase.auth.admin.getUserById(token.creator_id);
        creatorEmail = authUser?.user?.email || null;
      }

      if (!profileError && creatorProfile && creatorEmail) {
        const creatorName = creatorProfile.first_name || creatorProfile.last_name
          ? `${creatorProfile.first_name || ''} ${creatorProfile.last_name || ''}`.trim()
          : 'Creator';

        const brandData = {
          brandName: formData.brandName || 'Brand',
          campaignName: formData.campaignName,
          dealType: formData.dealType || 'paid',
          paymentAmount: formData.dealType === 'paid' && formData.paymentAmount
            ? parseFloat(formData.paymentAmount) || 0
            : undefined,
          deliverables: formData.deliverables || [],
          deadline: formData.deadline,
        };

        // Send email asynchronously (don't await to avoid blocking)
        sendBrandFormSubmissionEmail(
          creatorEmail,
          creatorName,
          brandData,
          dealId
        ).then((result) => {
          if (result.success) {
            console.log('[DealDetailsTokenService] Email notification sent successfully:', result.emailId);
          } else {
            console.warn('[DealDetailsTokenService] Failed to send email notification:', result.error);
          }
        }).catch((error) => {
          console.error('[DealDetailsTokenService] Error sending email notification:', error);
        });
      } else {
        console.warn('[DealDetailsTokenService] Could not fetch creator email for notification:', profileError);
      }
    } catch (emailError) {
      // Don't fail the submission if email fails
      console.error('[DealDetailsTokenService] Error preparing email notification:', emailError);
    }
  }

  // Always create contract ready token (no more clarification mode)
  let contractReadyToken: string | null = null;
  
  if (dealId) {
    try {
      console.log('[DealDetailsTokenService] Creating contract ready token for deal:', dealId, 'creator:', token.creator_id);
      // Generate contract ready token for brand to sign
      const { createContractReadyToken } = await import('./contractReadyTokenService.js');
      const readyToken = await createContractReadyToken({
        dealId: dealId,
        creatorId: token.creator_id,
        expiresAt: null, // No expiration
      });
      contractReadyToken = readyToken.id;
      console.log('[DealDetailsTokenService] ✅ Contract ready token generated successfully:', contractReadyToken);
      
      // Send contract email to brand (non-blocking)
      try {
        // Fetch deal to get contract URL and brand email
        const { data: dealData } = await supabase
          .from('brand_deals')
          .select('contract_file_url, brand_email, brand_name')
          .eq('id', dealId)
          .maybeSingle();

        if (dealData && dealData.brand_email) {
          // Fetch creator details
          const { data: creatorData } = await supabase
            .from('profiles')
            .select('first_name, last_name')
            .eq('id', token.creator_id)
            .maybeSingle();

          // Get email from auth.users
          let creatorEmail: string | null = null;
          if (creatorData) {
            try {
              const { data: authUser } = await supabase.auth.admin.getUserById(token.creator_id);
              creatorEmail = authUser?.user?.email || null;
            } catch (authError) {
              console.warn('[DealDetailsTokenService] Could not fetch creator email from auth:', authError);
            }
          }

          if (creatorData && creatorEmail) {
            const { sendBrandContractReadyEmail } = await import('./brandContractReadyEmailService.js');
            
            const creatorName = creatorData.first_name && creatorData.last_name
              ? `${creatorData.first_name} ${creatorData.last_name}`
              : creatorData.first_name || creatorEmail?.split('@')[0] || 'Creator';

            // Parse deliverables from formData
            const deliverablesList = Array.isArray(formData.deliverables) 
              ? formData.deliverables.map((d: any) => 
                  `${d.quantity || 1}x ${d.contentType || 'Content'} on ${d.platform || 'Platform'}`
                )
              : ['As per agreement'];

            const contractData = {
              brandName: dealData.brand_name || formData.brandName || 'Brand',
              creatorName: creatorName,
              dealAmount: formData.dealType === 'paid' && formData.paymentAmount
                ? parseFloat(formData.paymentAmount) || 0
                : undefined,
              dealType: (formData.dealType || 'paid') as 'paid' | 'barter',
              deliverables: deliverablesList,
              deadline: formData.deadline,
              contractUrl: dealData.contract_file_url || undefined,
              contractReadyToken: contractReadyToken,
            };

            // Send email asynchronously
            sendBrandContractReadyEmail(
              dealData.brand_email,
              contractData.brandName,
              contractData
            ).then((result) => {
              if (result.success) {
                console.log('[DealDetailsTokenService] ✅ Contract email sent to brand:', result.emailId);
              } else {
                console.warn('[DealDetailsTokenService] Failed to send contract email to brand:', result.error);
              }
            }).catch((error) => {
              console.error('[DealDetailsTokenService] Error sending contract email to brand:', error);
            });
          }
        }
      } catch (emailError) {
        // Don't fail the submission if email fails
        console.error('[DealDetailsTokenService] Error preparing contract email to brand:', emailError);
      }
    } catch (tokenError: any) {
      console.error('[DealDetailsTokenService] ❌ Failed to generate contract ready token');
      console.error('[DealDetailsTokenService] Error details:', {
        message: tokenError.message,
        stack: tokenError.stack,
        dealId: dealId,
        creatorId: token.creator_id,
        error: tokenError
      });
      // Don't fail the submission if token generation fails, but log extensively
      contractReadyToken = null; // Explicitly set to null on error
    }
  } else {
    console.warn('[DealDetailsTokenService] ⚠️ No dealId available, cannot create contract ready token');
    console.warn('[DealDetailsTokenService] Deal creation may have failed. Check logs above for deal creation errors.');
  }

  return {
    submissionId: submission.id,
    dealId,
    contractReadyToken, // Token for contract ready page
  };
}

/**
 * Get submitted deal details for a deal (creator access)
 * @param dealId Deal ID
 * @returns Submission data if exists
 */
export async function getDealSubmissionDetails(dealId: string): Promise<{
  submission: any;
  formData: any;
} | null> {
  const { data: submission, error } = await supabase
    .from('deal_details_submissions')
    .select('*, deal_details_tokens!inner(*)')
    .eq('deal_id', dealId)
    .maybeSingle();

  if (error || !submission) {
    return null;
  }

  return {
    submission,
    formData: submission.form_data,
  };
}

