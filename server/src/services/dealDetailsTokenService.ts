// @ts-nocheck
import { supabase } from '../index.js';
import { sendBrandFormSubmissionEmail } from './brandFormSubmissionEmailService.js';

/**
 * Determines if brand confirmation/clarification page is required
 * Returns true if any problematic conditions are detected
 */
export function shouldRequireBrandConfirmation(deal: any): boolean {
  // If creator requested edits earlier
  if (deal.creatorRequestedChanges) return true;

  // If AI flagged missing clarity
  if (deal.flags?.requiresClarification === true) return true;

  // If usage rights missing or incomplete
  if (!deal.usage || !deal.usage.duration) return true;

  // If payment terms vague or missing
  if (!deal.payment?.timeline || !deal.payment?.method) return true;

  // If exclusivity unclear
  if (deal.exclusivity?.status === "unknown") return true;

  // If brand skipped critical fields
  const required = ["deliverables", "deadline", "amount"];
  for (const field of required) {
    if (!deal[field]) return true;
  }

  // If nothing problematic → NO confirmation needed
  return false;
}

export interface DealDetailsToken {
  id: string;
  creator_id: string;
  is_active: boolean;
  expires_at: string | null;
  revoked_at: string | null;
  used_at: string | null; // Timestamp when brand submitted (locks form)
  created_at: string;
  updated_at: string;
}

export interface CreateDealDetailsTokenOptions {
  creatorId: string;
  expiresAt?: Date | null;
}

/**
 * Create a secure deal details token
 * @param options Token creation options
 * @returns The created token
 */
export async function createDealDetailsToken(
  options: CreateDealDetailsTokenOptions
): Promise<DealDetailsToken> {
  const { creatorId, expiresAt } = options;

  // Validate inputs
  if (!creatorId) {
    throw new Error('creatorId is required');
  }

  // Create token (UUID v4 is generated by database default)
  const { data: token, error: tokenError } = await supabase
    .from('deal_details_tokens')
    .insert({
      creator_id: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    })
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[DealDetailsTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create deal details token');
  }

  return token;
}

/**
 * Get token info (public access for form page)
 * @param tokenId Token ID
 * @returns Token info with creator name
 */
export async function getDealDetailsTokenInfo(tokenId: string): Promise<{
  token: DealDetailsToken;
  creatorName: string;
} | null> {
  // Validate token format (UUID v4)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(tokenId.trim())) {
    return null;
  }

  // Fetch token with creator info
  const { data: tokenData, error: tokenError } = await supabase
    .from('deal_details_tokens')
    .select(`
      *,
      profiles:creator_id (
        first_name,
        last_name
      )
    `)
    .eq('id', tokenId.trim())
    .maybeSingle();

  if (tokenError || !tokenData) {
    return null;
  }

  // Check if token is active
  if (!tokenData.is_active || tokenData.revoked_at) {
    return null;
  }

  // Check if token is expired
  if (tokenData.expires_at) {
    const expiresAt = new Date(tokenData.expires_at);
    if (expiresAt < new Date()) {
      return null;
    }
  }

  // Note: We still return token info even if used_at is set (for read-only view)

  // Extract creator name
  const profile = tokenData.profiles as any;
  const creatorName = profile
    ? `${profile.first_name || ''} ${profile.last_name || ''}`.trim() || 'the creator'
    : 'the creator';

  return {
    token: tokenData as DealDetailsToken,
    creatorName,
  };
}

/**
 * Submit deal details form
 * @param tokenId Token ID
 * @param formData Form submission data
 * @returns Created deal ID (if deal was created)
 */
export async function submitDealDetails(
  tokenId: string,
  formData: any
): Promise<{ submissionId: string; dealId: string | null; contractReadyToken: string | null }> {
  // Validate token
  const tokenInfo = await getDealDetailsTokenInfo(tokenId);
  if (!tokenInfo) {
    throw new Error('Invalid or expired token');
  }

  const { token } = tokenInfo;

  // Check if token has already been used (immutability)
  if (token.used_at) {
    throw new Error('This form has already been submitted and cannot be edited. Please contact the creator for changes.');
  }

  // Mark token as used (lock the form)
  const { error: updateError } = await supabase
    .from('deal_details_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('id', tokenId);

  if (updateError) {
    console.error('[DealDetailsTokenService] Token update error:', updateError);
    // Continue anyway - submission is more important
  }

  // Create submission
  const { data: submission, error: submissionError } = await supabase
    .from('deal_details_submissions')
    .insert({
      token_id: tokenId,
      creator_id: token.creator_id,
      form_data: formData,
    })
    .select()
    .single();

  if (submissionError || !submission) {
    console.error('[DealDetailsTokenService] Submission error:', submissionError);
    throw new Error('Failed to submit deal details');
  }

  // DO NOT create deal here - deals are only created when signed
  // Just save the submission and generate contract
  let dealId: string | null = null;

  // Generate contract and store with submission (deals are only created when signed)
  try {
    console.log('[DealDetailsTokenService] Generating contract for submission...');
    
    // Import contract generation service
    const { generateContractFromScratch } = await import('./contractGenerator.js');
    
    // Fetch creator details
    const { data: creator, error: creatorError } = await supabase
      .from('profiles')
      .select('id, first_name, last_name, address, location')
      .eq('id', token.creator_id)
      .single();
    
    // Get email from auth.users
    let creatorEmail: string | null = null;
    if (creator) {
      const { data: authUser } = await supabase.auth.admin.getUserById(token.creator_id);
      creatorEmail = authUser?.user?.email || null;
    }

    if (!creatorError && creator) {
      // Parse deliverables
      const deliverablesList = Array.isArray(formData.deliverables) 
        ? formData.deliverables.map((d: any) => 
            `${d.quantity || 1}x ${d.contentType || 'Content'} on ${d.platform || 'Platform'}`
          )
        : ['As per agreement'];

      // Build contract generation request
      const creatorName = creator.first_name && creator.last_name
        ? `${creator.first_name} ${creator.last_name}`
        : creator.first_name || creator.email?.split('@')[0] || 'Creator';

      // Get creator address
      let creatorAddress: string | null = null;
      const locationValue = creator.location;
      const addressValue = creator.address;
      
      const rawAddress = (locationValue && typeof locationValue === 'string' && locationValue.trim() !== '' && locationValue.toLowerCase() !== 'n/a')
        ? locationValue.trim()
        : (addressValue && typeof addressValue === 'string' && addressValue.trim() !== '' && addressValue.toLowerCase() !== 'n/a')
          ? addressValue.trim()
          : null;
      
      creatorAddress = rawAddress;

      const dealAmount = formData.dealType === 'paid' && formData.paymentAmount
        ? parseFloat(formData.paymentAmount) || 0
        : 0;

      const contractRequest = {
        brandName: formData.brandName || 'Brand',
        creatorName: creatorName,
        dealAmount: dealAmount,
        deliverables: deliverablesList,
        brandEmail: formData.companyEmail || null,
        brandAddress: formData.companyAddress || null,
        creatorEmail: creatorEmail || null,
        creatorAddress: creatorAddress,
        dealSchema: {
          usage_type: formData.usageRightsDuration || '3_months',
          usage_platforms: formData.deliverables?.map((d: any) => d.platform) || ['Instagram'],
          usage_duration: formData.usageRightsDuration || '3_months',
          paid_ads_allowed: formData.paidAdsAllowed || false,
          whitelisting_allowed: formData.whitelistingAllowed || false,
          exclusivity_enabled: formData.exclusivityPeriod && formData.exclusivityPeriod !== 'none',
          exclusivity_duration: formData.exclusivityPeriod || null,
          payment_method: formData.paymentMethod?.[0] || null,
          payment_timeline: formData.paymentTimeline || null,
        },
        usageType: formData.usageRightsDuration || '3_months',
        usagePlatforms: formData.deliverables?.map((d: any) => d.platform) || ['Instagram'],
        usageDuration: formData.usageRightsDuration || '3_months',
        paidAdsAllowed: formData.paidAdsAllowed || false,
        whitelistingAllowed: formData.whitelistingAllowed || false,
        exclusivityEnabled: formData.exclusivityPeriod && formData.exclusivityPeriod !== 'none',
        exclusivityCategory: null,
        exclusivityDuration: formData.exclusivityPeriod || null,
        terminationNoticeDays: null,
        jurisdictionCity: formData.companyState || null,
        additionalTerms: null,
      };

      // Generate contract
      const contractResult = await generateContractFromScratch(contractRequest);

      // Upload contract DOCX to storage using submission_id instead of deal_id
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('creator-assets')
        .upload(
          `contracts/submissions/${submission.id}/${contractResult.fileName}`,
          contractResult.contractDocx,
          {
            contentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            upsert: true
          }
        );

      if (!uploadError && uploadData) {
        // Get public URL
        const { data: urlData } = await supabase.storage
          .from('creator-assets')
          .getPublicUrl(uploadData.path);

        console.log('[DealDetailsTokenService] Contract generated and stored for submission:', submission.id);
      } else {
        console.error('[DealDetailsTokenService] Contract upload failed:', uploadError);
      }
    } else {
      console.error('[DealDetailsTokenService] Creator not found for contract generation');
    }
  } catch (contractError: any) {
    console.error('[DealDetailsTokenService] Contract generation failed (non-fatal):', contractError);
  }

  // Send email notification to creator (non-blocking) - use submission instead of deal
  {
    try {
      // Fetch creator's profile
      const { data: creatorProfile, error: profileError } = await supabase
        .from('profiles')
        .select('first_name, last_name')
        .eq('id', token.creator_id)
        .maybeSingle();

      // Get email from auth.users
      let creatorEmail: string | null = null;
      if (!profileError && creatorProfile) {
        const { data: authUser } = await supabase.auth.admin.getUserById(token.creator_id);
        creatorEmail = authUser?.user?.email || null;
      }

      if (!profileError && creatorProfile && creatorEmail) {
        const creatorName = creatorProfile.first_name || creatorProfile.last_name
          ? `${creatorProfile.first_name || ''} ${creatorProfile.last_name || ''}`.trim()
          : 'Creator';

        const brandData = {
          brandName: formData.brandName || 'Brand',
          campaignName: formData.campaignName,
          dealType: formData.dealType || 'paid',
          paymentAmount: formData.dealType === 'paid' && formData.paymentAmount
            ? parseFloat(formData.paymentAmount) || 0
            : undefined,
          deliverables: formData.deliverables || [],
          deadline: formData.deadline,
        };

        // Send email asynchronously (don't await to avoid blocking)
        sendBrandFormSubmissionEmail(
          creatorEmail,
          creatorName,
          brandData,
          submission.id // Use submission ID instead of deal ID
        ).then((result) => {
          if (result.success) {
            console.log('[DealDetailsTokenService] Email notification sent successfully:', result.emailId);
          } else {
            console.warn('[DealDetailsTokenService] Failed to send email notification:', result.error);
          }
        }).catch((error) => {
          console.error('[DealDetailsTokenService] Error sending email notification:', error);
        });
      } else {
        console.warn('[DealDetailsTokenService] Could not fetch creator email for notification:', profileError);
      }
    } catch (emailError) {
      // Don't fail the submission if email fails
      console.error('[DealDetailsTokenService] Error preparing email notification:', emailError);
    }
  }

  // Create contract ready token using submission_id (deal will be created when signed)
  let contractReadyToken: string | null = null;
  
  try {
    console.log('[DealDetailsTokenService] Creating contract ready token for submission:', submission.id, 'creator:', token.creator_id);
    const { createContractReadyToken } = await import('./contractReadyTokenService.js');
    
    // Create token with submission_id (deal will be created when signed)
    const readyToken = await createContractReadyToken({
      submissionId: submission.id,
      creatorId: token.creator_id,
      expiresAt: null, // No expiration
    });
    
    contractReadyToken = readyToken.id;
    console.log('[DealDetailsTokenService] ✅ Contract ready token generated successfully:', contractReadyToken);
  } catch (tokenError: any) {
    console.error('[DealDetailsTokenService] ❌ Failed to generate contract ready token:', tokenError);
    contractReadyToken = null;
  }

  return {
    submissionId: submission.id,
    dealId,
    contractReadyToken, // Token for contract ready page
  };
}

/**
 * Get submitted deal details for a deal (creator access)
 * @param dealId Deal ID
 * @returns Submission data if exists
 */
export async function getDealSubmissionDetails(dealId: string): Promise<{
  submission: any;
  formData: any;
} | null> {
  const { data: submission, error } = await supabase
    .from('deal_details_submissions')
    .select('*, deal_details_tokens!inner(*)')
    .eq('deal_id', dealId)
    .maybeSingle();

  if (error || !submission) {
    return null;
  }

  return {
    submission,
    formData: submission.form_data,
  };
}

