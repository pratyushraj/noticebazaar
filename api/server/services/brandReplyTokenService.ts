// Service to generate secure brand reply tokens
// Creates UUID v4 tokens for unguessable, non-sequential brand reply URLs

import { supabase } from '../index';

export interface CreateTokenOptions {
  dealId: string;
  creatorId: string;
  expiresAt?: Date | null; // null = no expiry (default)
}

export interface BrandReplyToken {
  id: string;
  deal_id: string;
  created_at: string;
  created_by: string;
  expires_at: string | null;
  is_active: boolean;
  revoked_at: string | null;
}

/**
 * Create a secure brand reply token for a deal
 * @param options Token creation options
 * @returns The created token
 */
export async function createBrandReplyToken(
  options: CreateTokenOptions
): Promise<BrandReplyToken> {
  const { dealId, creatorId, expiresAt } = options;

  // Validate inputs
  if (!dealId || !creatorId) {
    throw new Error('dealId and creatorId are required');
  }

  // Verify deal exists and belongs to creator
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('id, creator_id')
    .eq('id', dealId)
    .eq('creator_id', creatorId)
    .maybeSingle();

  if (dealError || !deal) {
    throw new Error('Deal not found or access denied');
  }

  // Create token (UUID v4 is generated by database default)
  const { data: token, error: tokenError } = await supabase
    .from('brand_reply_tokens')
    .insert({
      deal_id: dealId,
      created_by: creatorId,
      expires_at: expiresAt ? expiresAt.toISOString() : null,
      is_active: true,
    } as any)
    .select()
    .single();

  if (tokenError || !token) {
    console.error('[BrandReplyTokenService] Token creation error:', tokenError);
    throw new Error('Failed to create brand reply token');
  }

  return token;
}

/**
 * Revoke a brand reply token
 * @param tokenId Token ID to revoke
 * @param creatorId Creator ID (for authorization)
 */
export async function revokeBrandReplyToken(
  tokenId: string,
  creatorId: string
): Promise<void> {
  // Verify token belongs to creator
  const result = await supabase
    .from('brand_reply_tokens')
    .select('id, created_by')
    .eq('id', tokenId)
    .maybeSingle();
  
  const token = result.data as { id: string; created_by: string } | null;
  const tokenError = result.error;

  if (tokenError || !token) {
    throw new Error('Token not found');
  }

  if (token.created_by !== creatorId) {
    throw new Error('Access denied');
  }

  // Revoke token
  const { error: updateError } = await supabase
    .from('brand_reply_tokens')
    .update({
      is_active: false,
      revoked_at: new Date().toISOString(),
      revoked_by: creatorId,
    } as any)
    .eq('id', tokenId);

  if (updateError) {
    console.error('[BrandReplyTokenService] Token revocation error:', updateError);
    throw new Error('Failed to revoke token');
  }
}

/**
 * Get audit summary for a deal (read-only, for creators)
 * Audit logs are for transparency and record-keeping, not legal binding or advice.
 * 
 * Data minimization: Only exposes first viewed at, latest decision, last updated at.
 * IP addresses, user agents, and internal metadata are never exposed.
 * 
 * @param dealId Deal ID
 * @param creatorId Creator ID (for authorization)
 */
export async function getAuditSummary(
  dealId: string,
  creatorId: string
): Promise<{
  firstViewedAt: string | null;
  latestDecision: string | null;
  lastUpdatedAt: string | null;
}> {
  // Verify deal belongs to creator
  const { data: deal, error: dealError } = await supabase
    .from('brand_deals')
    .select('id, creator_id')
    .eq('id', dealId)
    .eq('creator_id', creatorId)
    .maybeSingle();

  if (dealError || !deal) {
    throw new Error('Deal not found or access denied');
  }

  // Get tokens for this deal (using indexed columns)
  const { data: tokens, error: tokensError } = await supabase
    .from('brand_reply_tokens')
    .select('id')
    .eq('deal_id', dealId) // Uses index: idx_brand_reply_tokens_deal_id
    .eq('created_by', creatorId);

  if (tokensError || !tokens || tokens.length === 0) {
    return {
      firstViewedAt: null,
      latestDecision: null,
      lastUpdatedAt: null,
    };
  }

  const tokenIds = (tokens as any[]).map((t: any) => t.id);

  // Get first viewed action (data minimization: only timestamp)
  const firstViewedResult = await supabase
    .from('brand_reply_audit_log')
    .select('action_timestamp')
    .eq('deal_id', dealId) // Uses index: idx_brand_reply_audit_log_deal_id
    .eq('action_type', 'viewed') // Uses index: idx_brand_reply_audit_log_action_type
    .in('reply_token_id', tokenIds) // Uses index: idx_brand_reply_audit_log_token_id
    .order('action_timestamp', { ascending: true })
    .limit(1)
    .maybeSingle();
  
  const firstViewed = firstViewedResult.data as { action_timestamp: string } | null;

  // Get latest decision (data minimization: only action_type and timestamp)
  const latestDecisionResult = await supabase
    .from('brand_reply_audit_log')
    .select('action_type, action_timestamp')
    .eq('deal_id', dealId) // Uses index
    .in('action_type', ['accepted', 'negotiation_requested', 'rejected', 'updated_response']) // Uses index
    .in('reply_token_id', tokenIds) // Uses index
    .order('action_timestamp', { ascending: false }) // Uses index: idx_brand_reply_audit_log_timestamp
    .limit(1)
    .maybeSingle();
  
  const latestDecision = latestDecisionResult.data as { action_type: string; action_timestamp: string } | null;

  // Return only safe, minimal data (no IP, user agent, or internal metadata)
  return {
    firstViewedAt: firstViewed ? firstViewed.action_timestamp : null,
    latestDecision: latestDecision ? latestDecision.action_type : null,
    lastUpdatedAt: latestDecision ? latestDecision.action_timestamp : null,
  };
}

